"""An interface for working with the Mark10 Tensile Tester"""
from typing import Tuple, List
import re
import os
import matplotlib.pyplot as plt
import numpy as np


def parse_log_file(
    filepath: str,
    to_csv: bool = False,
    trim_leading_zeros: bool = True,
    shift_time_to_zero: bool = True,
) -> Tuple[List[float], List[float]]:
    """Extract the time and force readings from a mark_10 log file. This function assumes that you have not modified the contents of the log file in any way.

    Args:
        filepath (str): The path to the file containing the data
        to_csv (bool, optional): Whether or not to save the data to a csv file of the same name with columns [time, force]. Defaults to False.
        trim_leading_zeros (bool, optional): Whether or not to strip force values reading 0.00 at the head of the data. Defaults to True.
        shift_time_to_zero (bool, optional): Whether or not to, after normalization from trimming data, shift the time values to start at 0. Defaults to True.

    Returns:
        Tuple[List[float], List[float]]: The extracted data in the same units as the input file, as [time_readings, force_readings]
    """
    force_unit = "N"
    time_unit = "sec."
    time_readings, force_readings = [], []
    with open(filepath, "r") as f:
        metadata = f.readline()
        labels = f.readline()
        units = re.findall(r"\[(.*?)\]", labels)
        force_unit, time_unit = units[0], units[1]
        for line in f.readlines():
            vals = line.split()
            time_readings.append(vals[-1])
            force_readings.append(vals[1])

    time_readings = [float(val) for val in time_readings]
    force_readings = [float(val) for val in force_readings]
    if trim_leading_zeros:
        while force_readings and force_readings[0] == 0:
            time_readings.pop(0)
            force_readings.pop(0)
    if shift_time_to_zero:
        min_time = min(time_readings)
        time_readings = [t_orig - min_time for t_orig in time_readings]
    assert len(time_readings) == len(force_readings)

    if to_csv:
        converted_path = filepath.replace(".log", ".csv")
        with open(converted_path, "w") as f:
            f.write(f"Time [{time_unit}],Load [{force_unit}]\n")
            for time, force in zip(time_readings, force_readings):
                f.write(f"{time},{force}\n")
    return (time_readings, force_readings)


def to_stress_strain(
    time_data: List[float],
    force_data: List[float],
    thickness_mm: float,
    width_mm: float,
    initial_length_mm: float,
    speed_mm_min: float,
) -> Tuple[List[float], List[float]]:
    """Extracts stress(MPa)-strain(mm/mm) data of data extracted from the Mark-10 output

    Args:
        time_data (List[float]): The time data
        force_data (List[float]): THe force data
        thickness_mm (float): The thickness of the gauge of your sample, in millimeters
        width_mm (float): The width of the gauge of your sample, in millimeters
        initial_length_mm (float): The initial length of the gauge of your sample, in millimeters
        speed_mm_min (float): The speed the travel moves, in mm/min

    Returns:
        Tuple[List[float], List[float]]: The data returned as [stress (MPa), strain (mm/mm)]
    """
    cross_sectional_area = thickness_mm * width_mm
    stress = [-load / cross_sectional_area for load in force_data]
    speed_mm_sec = speed_mm_min / 60.0
    travel = [speed_mm_sec * sec for sec in time_data]
    strain = [(travel_val / initial_length_mm) for travel_val in travel]
    return (stress, strain)


def estimate_modulus(
    time_data: List[float],
    force_data: List[float],
    thickness_mm: float,
    width_mm: float,
    initial_length_mm: float,
    speed_mm_min: float,
    start_point: int = 0,
    n_points: int = 2,
) -> float:
    """Estimate the youngs modulus from the first n points of the data. Estimate generated by ChatGPT, so use wisely

    Args:
        time_data (List[float]): The extracted time data from the Mark10
        force_data (List[float]): The extracted force data from the Mark10
        thickness_mm (float): The thickness of your sample in millimeters
        width_mm (float): The width of your sample in millimeters
        initial_length_mm (float): The initial length of your sample in millimeters
        speed_mm_min (float): The speed of the Mark10 in millimeters/min
        start_point (int, optional): The point to start suing data for the modulus. Defaults to 0.
        n_points (int, optional): The number of points to use for the calculation. Defaults to 2

    Raises:
        ValueError: If there are not n_points in the data starting at start_point
        
    Returns:
        float: The estimated young's modulus in the same units as the input force data
    """
    stress, strain = to_stress_strain(
        time_data, force_data, thickness_mm, width_mm, initial_length_mm, speed_mm_min
    )
    strain = np.array(strain)
    stress = np.array(stress)

    # Take first n points for elastic fit
    if len(strain) < n_points:
        raise ValueError("Not enough points to calculate modulus.")
    elastic_strain = strain[start_point : (start_point + n_points)]
    elastic_stress = stress[start_point : (start_point + n_points)]
    m, _ = np.polyfit(elastic_strain, elastic_stress, 1)

    return m


def plot_single_stress_strain_from_extracted(
    time_data: List[float],
    force_data: List[float],
    thickness_mm: float,
    width_mm: float,
    initial_length_mm: float,
    speed_mm_min: float,
    name: str,
    mark_yield_point_as_max: bool = False,
    plot_modulus_line: bool = False,
    strain_to_percent: bool = False,
    output_image_dir: str = "./data/Mark10",
    output_image_ext: str = "png",
    title: str = "Stress-Strain Curve",
    x_label: str = "Tensile Strain (mm/mm)",
    y_label: str = "Tensile Stress (MPa)",
    axis_font_size: int = 25,
    title_font_size: int = 30,
    legend_font_size: int = 20,
    legend: bool = False,
    legend_loc: str = "upper right",
    line_color: str = "black",
    yield_point_color: str = "red",
    modulus_line_color: str = "blue",
    grid: bool = False,
    figsize: Tuple[int, int] = (12, 9),
    modulus_start_point: int = 0,
    modulus_n_points: int = 2,
) -> None:
    """Plots stress-strain data from extracted mark10 data.

    THIS SHOULD NOT BE USED FOR YIELD POINT AND MODULUS LINE IN LARGER WORKS, IT IS MORE OF A PROOF OF CONCEPT

    Args:
        time_data (List[float]): The time data
        force_data (List[float]): THe force data
        thickness_mm (float): The thickness of the gauge of your sample, in millimeters
        width_mm (float): The width of the gauge of your sample, in millimeters
        initial_length_mm (float): The initial length of the gauge of your sample, in millimeters
        speed_mm_min (float): The speed the travel moves, in mm/min
        name (str): The desired name of the image to save, without the file extension.
        mark_yield_point_as_max (bool, optional): Whether or not to mark the yield point on the graph at the maximum stress point. Will only work for some materials. Defaults to False.
        plot_modulus_line (bool, optional): Whether or not to plot the estimated young's modulus on the graph. Defaults to False.
        strain_to_percent (bool, optional): Whether or not to convert the strain to a percentage. The state of this variable does not affect the inputted unit for strain. You must change that input yourself. Defaults to True.
        output_image_dir (str, optional): The directory to store the output image in. Defaults to "./data/Mark10".
        output_image_ext (str, optional): The file extension to use for the output image, without the period. Defaults to "png".
        title (str, optional): The title to use for the plot. Defaults to "Stress-Strain Curve".
        x_label (str, optional): The label to use for strain. Defaults to "Tensile Strain (mm/mm)".
        y_label (str, optional): The label to use for stress. Defaults to "Tensile Stress (MPa)".
        axis_font_size (int, optional): The fontsize to use for the axes. Defaults to 25.
        title_font_size (int, optional): The fontsize to use for the title. Defaults to 30.
        legend_font_size (int, optional): The fontsize to use for the legend. Defaults to 20.
        legend (bool, optional): Whether or not to show a legend with the data. Defaults to False.
        legend_loc (str, optional): The location to place the legend, if toggled on. Defaults to "upper right"
        line_color (str, optional): The color to use for the plotted line. Defaults to 'black'.
        yield_point_color (str, optional): The color to use for the point of the yield point, if toggled on. Defaults to 'red'.
        modulus_line_color (str, optional): The color to use for the line of the young's modulus, if toggled on. Defaults to 'blue'.
        grid (bool, optional): Whether or not to show a grid on the final plot. Defaults to False.
        figsize (Tuple[int, int], optional): The size of the figure to use. Defaults to (12,9).
        modulus_start_point (int, optional): The point to start suing data for the modulus. Unstable away from default. Defaults to 0.
        modulus_n_points (int, optional): The number of points to use for the calculation. Unstable away from default. Defaults to 2
    """
    os.makedirs(output_image_dir, exist_ok=True)
    image_path = os.path.join(output_image_dir, f"{name}.{output_image_ext}")
    stress, strain = to_stress_strain(
        time_data, force_data, thickness_mm, width_mm, initial_length_mm, speed_mm_min
    )

    if strain_to_percent:
        strain = [s * 100 for s in strain]

    plt.figure(figsize=figsize)
    plt.plot(strain, stress, color=line_color)

    if mark_yield_point_as_max or plot_modulus_line:
        if mark_yield_point_as_max:
            max_stress_idx = stress.index(max(stress))
            yield_strain, yield_stress = strain[max_stress_idx], stress[max_stress_idx]
            plt.scatter(
                yield_strain,
                yield_stress,
                color=yield_point_color,
                zorder=5,
                label=f"Yield Point: ({yield_strain:.1f} {'%' if strain_to_percent else 'mm/mm'}, {yield_stress:.1f} MPa)",
            )

        if plot_modulus_line:
            m = estimate_modulus(
                time_data,
                force_data,
                thickness_mm,
                width_mm,
                initial_length_mm,
                speed_mm_min,
                modulus_start_point,
                modulus_n_points
            )

            # Fit line through elastic region
            strain_min = min(strain)
            cutoff = 1.0004 * max(stress)

            elastic_strain = np.linspace(strain_min, cutoff, 10)
            elastic_stress = m * elastic_strain
            if strain_to_percent:
                elastic_strain = np.array([s * 100 for s in elastic_strain])
            plt.plot(
                elastic_strain,
                elastic_stress,
                color=modulus_line_color,
                linestyle="--",
                label=f"Modulus: {m:.2f} MPa",
            )

    plt.title(title, fontsize=title_font_size)
    plt.xlabel(x_label, fontsize=axis_font_size)
    plt.ylabel(y_label, fontsize=axis_font_size)
    if grid:
        plt.grid(True)
        
    if legend:
        plt.legend(fontsize=legend_font_size, loc=legend_loc)

    plt.tight_layout()
    print(f"Saving {os.path.abspath(image_path)}")
    print(f"\tCurrent File: {os.path.basename(image_path)}")
    plt.savefig(image_path)
    plt.show()


def plot_single_stress_strain_from_log_file(
    filepath: str,
    thickness_mm: float,
    width_mm: float,
    initial_length_mm: float,
    speed_mm_min: float,
    name: str = None,
    mark_yield_point_as_max: bool = False,
    plot_modulus_line: bool = False,
    strain_to_percent: bool = True,
    output_image_dir: str = "./data/Mark10",
    output_image_ext: str = "png",
    title: str = "Stress-Strain Curve",
    axis_font_size: int = 25,
    title_font_size: int = 30,
    legend_font_size: int = 20,
    legend: bool = False,
    legend_loc: str = 'upper right',
    line_color: str = "black",
    yield_point_color: str = "red",
    modulus_line_color: str = "blue",
    grid: bool = False,
    figsize: Tuple[int, int] = (12, 9),
    to_csv: bool = False,
    trim_leading_zeros: bool = True,
    modulus_start_point: int = 0,
    modulus_n_points: int = 2,
) -> None:
    """Plots stress-strain data from extracted mark10 data. This is the easiest way to interface with this module for single graph plots

    Args:
        filepath (str): The path to the file containing the data
        thickness_mm (float): The thickness of the gauge of your sample, in millimeters
        width_mm (float): The width of the gauge of your sample, in millimeters
        initial_length_mm (float): The initial length of the gauge of your sample, in millimeters
        speed_mm_min (float): The speed the travel moves, in mm/min
        name (str): The desired name of the image to save, without the file extension. When None, defaults to the stem of the input filepath. Defaults to None.
        mark_yield_point_as_max (bool, optional): Whether or not to mark the yield point on the graph at the maximum stress point. Will only work for some materials. Defaults to False.
        plot_modulus_line (bool, optional): Whether or not to plot the estimated young's modulus on the graph. Defaults to False.
        strain_to_percent (bool, optional): Whether or not to convert the strain to a percentage. Defaults to True.
        output_image_dir (str, optional): The directory to store the output image in. Defaults to "./data/Mark10".
        output_image_ext (str, optional): The file extension to use for the output image, without the period. Defaults to "png".
        title (str, optional): The title to use for the plot. Defaults to "Stress-Strain Curve".
        axis_font_size (int, optional): The fontsize to use for the axes. Defaults to 25.
        title_font_size (int, optional): The fontsize to use for the title. Defaults to 30.
        legend_font_size (int, optional): The fontsize to use for the legend. Defaults to 20.
        legend (bool, optional): Whether or not to show a legend with the data. Defaults to False.
        line_color (str, optional): The color to use for the plotted line. Defaults to 'black'.
        yield_point_color (str, optional): The color to use for the point of the yield point, if toggled on. Defaults to 'red'.
        modulus_line_color (str, optional): The color to use for the line of the young's modulus, if toggled on. Defaults to 'blue'.
        grid (bool, optional): Whether or not to show a grid on the final plot. Defaults to False.
        figsize (Tuple[int, int], optional): The size of the figure to use. Defaults to (12,9).
        to_csv (bool, optional): Whether or not to save the data to a csv file of the same name with columns [time, force]. Defaults to False.
        trim_leading_zeros (bool, optional): Whether or not to strip force values reading 0.00 at the head of the data. Defaults to True.
        modulus_start_point (int, optional): The point to start suing data for the modulus. Unstable away from default. Defaults to 0.
        modulus_n_points (int, optional): The number of points to use for the calculation. Unstable away from default. Defaults to 2

    """
    if name is None:
        name = os.path.splitext(os.path.basename(filepath))[0]
    time_data, force_data = parse_log_file(filepath, to_csv, trim_leading_zeros)
    x_label = ("Tensile Strain (mm/mm)",)
    y_label = ("Tensile Stress (MPa)",)

    if strain_to_percent:
        x_label = "Tensile Strain (%)"
    plot_single_stress_strain_from_extracted(
        time_data,
        force_data,
        thickness_mm,
        width_mm,
        initial_length_mm,
        speed_mm_min,
        name,
        mark_yield_point_as_max,
        plot_modulus_line,
        strain_to_percent,
        output_image_dir,
        output_image_ext,
        title,
        x_label,
        y_label,
        axis_font_size,
        title_font_size,
        legend_font_size,
        legend,
        legend_loc,
        line_color,
        yield_point_color,
        modulus_line_color,
        grid,
        figsize,
        modulus_start_point,
        modulus_n_points,
    )
    

def plot_multiple_stress_strains(
    filepaths: List[str],
    thicknesses_mm: List[float],
    widths_mm: List[float],
    initial_lengths_mm: List[float] | float,
    speeds_mm_min: List[float] | float,
    output_filename: str,
    labels: List[str] = [],
    title: str = "Stress-Strain Curves",
    x_label: str = "Tensile Strain (%)",
    y_label: str = "Tensile Stress (MPa)",
    legend: bool = True,
    legend_loc: str = "upper right",
    output_image_dir: str = "./data/Mark10",
    output_image_ext: str = "png",
    axis_font_size: int = 25,
    title_font_size: int = 30,
    legend_font_size: int = 20,
    colors: List[str] = None,
    grid: bool = False,
    figsize: Tuple[int, int] = (12,9),
    to_csv: bool = False,
    trim_leading_zeros: bool = True,
) -> None:
    """Plots multiple stress strain curves on the same plot

    Args:
        filepaths (List[str]): A list of filepaths with data to render
        thicknesses_mm (List[float]): The thicknesses of the gauge of your samples, in millimeters. This MUST be the same length as filepaths
        widths_mm (List[float]): The width of the gauge of your samples, in millimeters. This MUST be the same length as filepaths
        initial_lengths_mm (List[float] | float): The initial length of the gauge of your samples, in millimeters. If this is not the same length as filepaths, it will set every length to the first value. This is generally a safe assumption
        speeds_mm_min (List[float] | float): The speeds the travel moves, in mm/min. If this is not the same length as filepaths, it will set every speed to the first value. This is generally a safe assumption
        output_filename (str): The desired name of the output file.
        labels (List[str], optional): The labels for the legend if turned on. Will pad to a numbered list of `Specimen #`. Defaults to [].
        title (str, optional): The title to use for the final plot. Defaults to "Stress-Strain Curve".
        x_label (str, optional): The x-axis label to use. Defaults to "Tensile Strain (%)".
        y_label (str, optional): The y-axis label to use. Defaults to "Tensile Stress (MPa)".
        legend (bool, optional): Whether to show a legend on the final plot. Defaults to True.
        legend_loc (str, optional): The location of the legend. Defaults to "upper right".
        output_image_dir (str, optional): The directory to automatically save the image to. Defaults to "./data/Mark10".
        output_image_ext (str, optional): The extension to use for the generated and saved image. Defaults to "png".
        axis_font_size (int, optional): The fontsize to use for the plot's axes. Defaults to 25.
        title_font_size (int, optional): The fontsize to use for the plot title. Defaults to 30.
        legend_font_size (int, optional): The fontsize to use for the legend, if toggled on. Defaults to 20.
        colors (List[str], optional): The colors to use for each plot. Must provide enough colors for every plot. If None, uses default colors. Defaults to None.
        grid (bool, optional): Determines whether or not to show a gray grid on the plot. Defaults to False.
        figsize (Tuple[int, int], optional): The figsize to use for the figure. Defaults to (12,9).
        to_csv (bool, optional): Whether or not to save the data to a csv file of the same name with columns [time, force]. Defaults to False.
        trim_leading_zeros (bool, optional): Whether or not to strip force values reading 0.00 at the head of the data. Defaults to True.
    """
    num_files = len(filepaths)
    assert num_files == len(widths_mm) == len(thicknesses_mm), "Mismatch in lengths"
    
    # initial_lengths_mm can be different things
    if isinstance(initial_lengths_mm, list) and num_files != len(initial_lengths_mm):
        # the initial_length object is in fact an array, but not long enough
        initial_lengths_mm = [initial_lengths_mm[0]] * num_files
    elif isinstance(initial_lengths_mm, float) or isinstance(initial_lengths_mm, int):
        # the initial_length object is just a number, so make it an array with values all equal to that number
        initial_lengths_mm = [initial_lengths_mm] * num_files
            
    # speeds_mm_min can be different things
    if isinstance(speeds_mm_min, list) and num_files != len(speeds_mm_min):
        # the speeds_mm_min object is in fact an array, but not long enough
        speeds_mm_min = [speeds_mm_min[0]] * num_files
    elif isinstance(speeds_mm_min, float) or isinstance(speeds_mm_min, int):
        # the speeds_mm_min object is just a number, so make it an array with values all equal to that number
        speeds_mm_min = [speeds_mm_min] * num_files
        
    os.makedirs(output_image_dir, exist_ok=True)
    image_path = os.path.join(output_image_dir, f"{output_filename}.{output_image_ext}")
    use_usr_colors = colors is not None and len(colors) == num_files
    
    # Right pad labels to match number of filepaths
    idx = len(labels) + 1
    while (num_files > len(labels)):
        labels.append(f"Specimen {idx}")
        idx += 1
    
    # collect all of the data
    datum = []
    for i, filepath in enumerate(filepaths):
        time_data, force_data = parse_log_file(filepath, to_csv, trim_leading_zeros)
        thickness_mm = thicknesses_mm[i]
        width_mm = widths_mm[i]
        initial_length_mm = initial_lengths_mm[i]
        speed_mm_min = speeds_mm_min[i]
        stress, strain = to_stress_strain(
            time_data, force_data, thickness_mm, width_mm, initial_length_mm, speed_mm_min
        )
        strain = [s * 100 for s in strain]
        datum.append([strain, stress])
    
    plt.figure(figsize=figsize)
    for i in range(len(datum)):
        if use_usr_colors:
            plt.plot(*datum[i], label=labels[i], color=colors[i])
        else:
            plt.plot(*datum[i], label=labels[i])
    plt.title(title, fontsize=title_font_size)
    plt.xlabel(x_label, fontsize=axis_font_size)
    plt.ylabel(y_label, fontsize=axis_font_size)
    if legend: 
        plt.legend(fontsize=legend_font_size, loc=legend_loc)
    if grid:
        plt.grid(True)
    plt.tight_layout()
    print(f"Saving {os.path.abspath(image_path)}")
    print(f"\tCurrent File: {os.path.basename(image_path)}")
    plt.savefig(image_path)
    plt.show()